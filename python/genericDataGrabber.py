"""
.. module:: genericDataGrabber
    :platform: Unix, Windows
    :synopsis: Uses CoolProp to access thermodynamic data about Fluids.

.. moduleauthor:: Nick Meyer <nmeyer5435@gmail.com>
"""


# CoolProp is for getting the thermo data
# import CoolProp
import CoolProp.CoolProp as CP
# Matplotlib for making pretty pictures
import matplotlib.pyplot as plt
# Data Storage Containers
import numpy as np
import pandas as pd
from mpl_toolkits.mplot3d import Axes3D

from typing import Any, List, Tuple, TypeVar, Union

numList = TypeVar("numList", List[int], int)


class ThermoFluid():
    """
    A class that will contain the data requested in .data as a pandas DataFrame

    Attributes:
        xvar: (string) What variable is on the x-axis
        yvar: (string) What variable is on the y-axis
        zvar: (string) What variable is on the z-axis, also, what variable is generated by CoolProp
        colorMap: (string) What ColorMap Matplotlib uses to make its plot
        vars: (list of strings) a list of xvar, yvar, zvar
        fluid: What fluid is being modeled
        data: (pandas.DataFrame) The data for the given fluid
        units: (list of strings) the units for xvar, yvar, zvar, in that order.
        numPoints: (list of ints) the x-resolution and y-resolution, in that order.

    """

    def __init__(self, fluid: str="Water", var1: str="T", var2: str="P", outvar: str="S", numPoints: numList = [250, 250], colorMap: str="nipy_spectral"):
        """
        Call the class with these arguments

        Args:
            fluid (str): CoolProp Fluid type to use

            var1 (str): x var, normally T, P

            var2 (str): y var, normally P, V

            outvar (str): z var (generated by code), normally S, U

            numPoints (int or list of int): number of Points for linspaces

            colorMap (str): What color map to use

        """
        self.fluid: str
        self.fluid = fluid
        self.numPoints: numList
        if type(numPoints) is int:
            self.numPoints = [numPoints, numPoints]
        else:
            self.numPoints = [numPoints[0], numPoints[1]]
        self.colorMap: str
        self.xvar: str
        self.yvar: str
        self.zvar: str
        self.var: List[str]
        self.colorMap = colorMap
        self.xvar = var1
        self.yvar = var2
        self.zvar = outvar
        self.vars = [self.xvar, self.yvar, self.zvar]
        # Linear interpolation between tmin and tmax with NUM_POINTS number of
        # points, delta = tmax-min/NUM_POINTS
        xspace = np.linspace(CP.PropsSI(self.xvar + "MIN", self.fluid) +
                             0.1, CP.PropsSI(self.xvar + "MAX", self.fluid) - 0.1, self.numPoints[0])
        # Linear interpolation between pmin and pmax with NUM_POINTS number of
        # points, delta = max-min/NUM_POINTS
        yspace = np.linspace(CP.PropsSI(self.yvar + "MIN", self.fluid) +
                             0.1, CP.PropsSI(self.yvar + "MAX", self.fluid) - 0.1, self.numPoints[1])

        # Create a empty list for storing data
        # Then make our data.
        data = []

        for x in xspace:
            for y in yspace:
                data.append(
                    [x, y, CP.PropsSI(self.zvar, self.xvar, x, self.yvar, y, self.fluid)])

        # Create Pandas Frame of Data
        self.data: pd.DataFrame
        self.data = pd.DataFrame(np.asarray(data), columns=self.vars)

        if "P" in self.vars:
            self.data = self.data[self.data["P"] >= 10000]
        if "S" in self.vars:
            self.data = self.data[self.data["S"] > 0]
        if "T" in self.vars:
            self.data = self.data[self.data["T"] >= (
                CP.PropsSI('TMIN', self.fluid) + 1.0)]

        # Next block creates a list of the units that we need
        self.units: List[str]
        self.units = ["", "", ""]
        for i, var in enumerate(self.vars):
            if var == "P":
                self.units[i] = "Pa"
            elif var == "T":
                self.units[i] = "K"
            elif var == "S":
                self.units[i] = "J/kg/K"
            elif var == "G":
                self.units[i] = "J/kg"
            elif var == "U":
                self.units[i] = "J/kg"
            elif var == "D":
                self.units[i] = "kg/m^3"

    def make_csv(self):
        """
        Does what it says on the tin. Makes a CSV file and saves it to data/[XYZ].csv
        """
        self.data.to_csv("data/" + self.xvar + self.yvar + self.zvar + ".csv")

    def show_plot(self):
        """
        Does what it says on the tin. Makes a 3D Scatter Plot of the dataframe.
        """
        # Plotting:
        fig = plt.figure()
        ax = fig.add_subplot(111, projection="3d")  # we want 3D plots
        ax.scatter(self.data[self.xvar], self.data[self.yvar], self.data[self.zvar], c=self.data[
                   self.zvar], cmap=self.colorMap, edgecolors="none")  # Plot the data
        # Set the Labels
        ax.set_xlabel("{0} [{1}]".format(self.vars[0], self.units[0]))
        ax.set_ylabel("{0} [{1}]".format(self.vars[1], self.units[2]))
        ax.set_zlabel("{0} [{1}]".format(self.vars[2], self.units[2]))
        ax.set_title("{0} and {1} vs {2} of {3}".format(
            *self.vars, self.fluid))
        plt.show()
